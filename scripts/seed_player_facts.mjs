#!/usr/bin/env node
/**
 * seed_player_facts.mjs
 *
 * Reads all question files, extracts rules + answer pools, and generates
 * player_facts rows. Each answer in a question's pool gets a fact row
 * for EACH rule in that question.
 *
 * Usage:
 *   node scripts/seed_player_facts.mjs                # prints SQL to stdout
 *   node scripts/seed_player_facts.mjs --json         # prints JSON array
 *   node scripts/seed_player_facts.mjs --sql > out.sql # save to file
 */

// We dynamically import the question files (ESM)
import { NBA_POOLS } from "../src/data/questions_nba.js";
import { NFL_POOLS } from "../src/data/questions_nfl.js";
import { MLB_POOLS } from "../src/data/questions_mlb.js";
import { NHL_POOLS } from "../src/data/questions_nhl.js";
import { SOCCER_POOLS } from "../src/data/questions_soccer.js";
import { MULTI_POOLS } from "../src/data/questions_multi.js";

const ALL_POOLS = {
  ...NBA_POOLS,
  ...NFL_POOLS,
  ...MLB_POOLS,
  ...NHL_POOLS,
  ...SOCCER_POOLS,
  ...MULTI_POOLS,
};

const rows = [];
const seen = new Set();

for (const [qKey, q] of Object.entries(ALL_POOLS)) {
  if (!q.rules || !q.answers) {
    console.error(`WARN: question ${qKey} missing rules or answers, skipping`);
    continue;
  }

  for (const answer of q.answers) {
    for (const rule of q.rules) {
      const factValue = rule.fact_value ?? "true";
      const key = `${answer.name}|${q.sport}|${rule.fact_type}|${factValue}`;
      if (seen.has(key)) continue;
      seen.add(key);
      rows.push({
        player_name: answer.name,
        sport: q.sport,
        fact_type: rule.fact_type,
        fact_value: factValue,
      });
    }
  }
}

const mode = process.argv[2] ?? "--sql";

if (mode === "--json") {
  console.log(JSON.stringify(rows, null, 2));
} else {
  // SQL output — batched inserts
  const esc = (s) => s.replace(/'/g, "''");
  console.log("-- Auto-generated by seed_player_facts.mjs");
  console.log(`-- ${rows.length} fact rows from ${Object.keys(ALL_POOLS).length} questions\n`);
  console.log("INSERT INTO player_facts (player_name, sport, fact_type, fact_value) VALUES");

  const lines = rows.map(
    (r, i) =>
      `  ('${esc(r.player_name)}', '${esc(r.sport)}', '${esc(r.fact_type)}', '${esc(r.fact_value)}')${i < rows.length - 1 ? "," : ""}`
  );

  // Batch into chunks of 500 to avoid hitting SQL limits
  const BATCH = 500;
  for (let i = 0; i < lines.length; i += BATCH) {
    if (i > 0) {
      console.log(";\n\nINSERT INTO player_facts (player_name, sport, fact_type, fact_value) VALUES");
    }
    const batch = lines.slice(i, i + BATCH);
    // Fix trailing comma on last line of batch
    const last = batch.length - 1;
    if (i + BATCH < lines.length) {
      // Not the final batch — last line needs comma removed, add semicolon-less end
    }
    batch.forEach((line, j) => {
      if (j === last && i + BATCH >= lines.length) {
        // Very last line of very last batch — no comma
        console.log(line);
      } else if (j === last) {
        // Last line of intermediate batch — remove trailing comma
        console.log(line.replace(/,$/, ""));
      } else {
        console.log(line);
      }
    });
  }
  console.log("ON CONFLICT (player_name, sport, fact_type, fact_value) DO NOTHING;");

  console.log(`\n-- Total: ${rows.length} rows`);
}
